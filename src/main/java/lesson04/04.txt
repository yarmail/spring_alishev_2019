Урок 4: Инверсия управления. Inversion of Control (IoC).

Предположим у нас есть такой набор классов

----- (1 случай)
class ClassicalMusic {
//Код для доступа к классической музыке
}

class MusicPlayer {
    private ClassicalMusic classicalMusic;

    public void playMusic() {
    classicalMusic = new Classical Music();
    }
}

-----

Класс MusicPlayer зависит от ClassicalMusic
Здесь мы видим сильную зависимость, что есть нехорошо.
MusicPlayer "заточен" на работу только с ClassicalMusic
Если мы хотим воспроизводить не только классическую музыку
нам нужно другое решение.

Решение - использовать интерфейс или абстрактный класс
который бы обобщал различные музыкальные жанры.

От себя добавлю, что на этом примере видно,
что "сам класс управляет своими зависимостями"

----- (2 случай)

interface Music {
//... код который необходим для доступа к любому жанру музыки
}
class ClassicalMusic implements Music {
//... код для доступа к классической музыке
}

class RockMusic implements Music {
//... код для доступа к рок музыке
}

class MusicPlayer {
    private Music music; // смягчаем сцепку интефейсом

    public void playMusic() {
    music = new ClassicalMusic(); // но все равно сами управляем зависимостями
    //или
    music = new RockMusic();
    // ... код для воспроизведения музыки...
    }
}
----
Используя полиморфизм мы можем за счет интерфейса
выбрать в переменной ту или другую музыку.
Лучшей практикой считается писать слева интерфейс
List<Integer> list = new ArrayList<>();
В ходе работы над программой вы можете
изменить вашу реализацию и вам не придется
менять код везде.

Теперь у нас есть "слабая зависимость",
но мы всеравно вручную должны управлять присвоением
объектов в коде. Для решения
этого вопроса мы можем использовать Spring,
которой "снаружи", изменяя код (бины) в конфигурационном файле
позволит нам менять объект, не влезая в код программы

Делегирование создания объектов Спрингу, "внешнему"
управлению и называется IoC - инверсия управления,
передача управления от "внутреннего" "внешнему"

---- (3 случай) управление объектами внедряется снаружи
class MusicPlayer {
    private Music music; // продолжаем использовать Интерфейс
}
    //зависимость внедряется извне (IoC) через конструктор
    public MusicPlayer(Music music) {
    this.music = music;
    }
public void playMusic() {
    // Больше не создаем объекты сами
    // а Spring через конструктор нам их передает
    // ... Код для воспроизведения музыки...
}
----

Следующий вопрос - при пользовании нашим плеером
со стороны клиента
нам нужно создавать вручную дополнительно
объект, который будет проигрывть нашь плеер

---- (4 случай)
class UseMusicPlayer {
    public static void main (String[] ars) {
        MusicPlayer musicPlayer = new MusicPlayer(new ClassicalMusic());
    }
}
Этот воппрос также решает Spring с помощью
(Dependency Injection) в дальнейших уроках
(на этом уроке мы это сделаем сами)

---

Spring можно конфигурировать с помощью:
- XML файла конфигурации (старый способ)
- Java аннотаций и немного XML (современный способ)
- Вся конфигурация на Java коде (современный способ)

---

Теперь попробуем реализовать интерфейс Music
и работу плеера







